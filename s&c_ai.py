# -*- coding: utf-8 -*-
"""S&C AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1X5xR_0A3x14E5hCPL3cMpEfkcC4PESv3
"""

import numpy as np
import matplotlib.pyplot as plt
import random

class Boid:
    def __init__(self, position, velocity, inner_radius, outer_radius):
        self.position = np.array(position, dtype = float)
        self.velocity = np.array(velocity, dtype=float)
        self.inner_radius = inner_radius
        self.outer_radius = outer_radius

#Cohesion method with array normalization
# the function returns a movement vector, which represents the direction in which the current boid should move. This vector is determined by the difference between the average position of nearby boids and the current boid's position, scaled down by a factor of 100. The scaling factor is applied to control the magnitude or speed of the movement.
    def cohesion(self, boids):
        nearby_boids = [b for b in boids if np.linalg.norm(b.position - self.position) < self.outer_radius] #Creates a list for all boids if the euclidean distance of the position between 2 boids is less than the threshold
        if not nearby_boids:
            return np.zeros_like(self.position) #If the current boids has no neighbors return an array of zeros the same shape as the position array
        average_position = np.mean([b.position for b in nearby_boids], axis=0) #This line calculates the average position of all the nearby boids
        return (average_position - self.position) / 100  #Scaling factor


#Separation method with array normalization
    def separation(self, boids):
        nearby_boids = [b for b in boids if self.inner_radius < np.linalg.norm(b.position - self.position) < self.outer_radius]
        if not nearby_boids:
          return np.zeros_like(self.position, dtype=float)  #set data type to float

        separation_vector = np.zeros_like(self.position, dtype=float)
        for b in nearby_boids:
          separation_vector += (b.position - self.position) / np.linalg.norm(b.position - self.position)**2

        return separation_vector / 100 # Scaling Factor


#Alignment method with array normalization
# the function returns a movement vector, which represents the speed in which the current boid should move. This vector is determined by the difference between the average position of nearby boids and the current boid's position, scaled down by a factor of 100. The scaling factor is applied to control the magnitude or speed of the movement.
    def alignment(self, boids):
        nearby_boids = [b for b in boids if np.linalg.norm(b.position - self.position) < self.outer_radius]
        if not nearby_boids:
            return np.zeros_like(self.velocity)
        average_velocity = np.mean([b.velocity for b in nearby_boids], axis=0)
        return (average_velocity - self.velocity) / 100  # Scaling Factor


#Failed method of visualization of behaviours
def visualize_behavior(boids, behavior_function, num_steps):
    fig, axs = plt.subplots(num_steps, 1, figsize=(6, num_steps * 3))

    # Set fixed axis limits
    x_min, x_max = 0, 200
    y_min, y_max = 0, 200

    positions_history = np.zeros((num_steps, len(boids), 2))

    for step in range(num_steps):
        for boid_index, boid in enumerate(boids):
            force = behavior_function(boid, boids)
            boid.velocity += force
            boid.position += boid.velocity
            positions_history[step, boid_index, :] = boid.position

        axs[step].scatter(positions_history[step, :, 0], positions_history[step, :, 1], label=f'Step {step}')
        axs[step].set_title(f'Step {step}')
        axs[step].set_aspect('equal', adjustable='box')

    plt.xlabel('X-axis')
    plt.ylabel('Y-axis')
    plt.tight_layout()
    plt.show()


def visualize_separation(boids, num_steps):
    for step in range(num_steps):
        plt.clf()  # Clear the current plot

        for boid in boids:
            other_boids = [other for other in boids if other != boid]
            separation_force = boid.separation(other_boids)
            boid.velocity += separation_force
            boid.position += boid.velocity

            #Go around the plot if boid goes out of bounds by changing the position using mod 150, which is the max x and y of plot
            boid.position[0] = boid.position[0] % 150
            boid.position[1] = boid.position[1] % 150

        # Plot the Boids
        positions = np.array([boid.position for boid in boids])
        plt.scatter(positions[:, 0], positions[:, 1])

        plt.xlim(0, 150)  # Set x-axis from 0-150
        plt.ylim(0, 150)  # Set y-axis from 0-150
        plt.pause(0.5)    # Pause time between each plot

    plt.show() #Plot show


def visualize_cohesion(boids, num_steps):
    for step in range(num_steps):
        plt.clf()  # Clear the current plot

        for boid in boids:
            other_boids = [other for other in boids if other != boid]
            cohesion_force = boid.cohesion(other_boids)
            boid.position += cohesion_force

            #Go around the plot if boid goes out of bounds by changing the position using mod 150, which is the max x and y of plot
            boid.position[0] = boid.position[0] % 150
            boid.position[1] = boid.position[1] % 150

        # Plot the Boids
        positions = np.array([boid.position for boid in boids])
        plt.scatter(positions[:, 0], positions[:, 1])

        plt.xlim(0, 150)  # Set x-axis from 0-150
        plt.ylim(0, 150)  # Set y-axis from 0-150
        plt.pause(0.5)    # Pause time between each plot

    plt.show() #Plot show


def visualize_alignment(boids, num_steps):
    for step in range(num_steps):
        plt.clf()  # Clear the current plot

        for boid in boids:
            other_boids = [other for other in boids if other != boid]
            alignment_force = boid.alignment(other_boids)
            boid.velocity += alignment_force
            boid.position += boid.velocity

            #Go around the plot if boid goes out of bounds by changing the position using mod 150, which is the max x and y of plot
            boid.position[0] = boid.position[0] % 150
            boid.position[1] = boid.position[1] % 150

        # Plot the Boids
        positions = np.array([boid.position for boid in boids])
        plt.scatter(positions[:, 0], positions[:, 1])

        plt.xlim(0, 150)  # Set x-axis from 0-150
        plt.ylim(0, 150)  # Set y-axis from 0-150
        plt.pause(0.5)    # Pause time between each plot

    plt.show() #Plot show


#This method combines all behaviours of cohesion, separation, and alignment
#used in the variables alignment_force, cohesion_force, and separation_force,
#then they are added to the velocity and normalized by multiplying by 0.1
#then the position is incremented by the final velocity.
def visualize_flocking(boids, num_steps):
    for step in range(num_steps):
        plt.clf()  # Clear the current plot

        for boid in boids:
            other_boids = [other for other in boids if other != boid]
            alignment_force = boid.alignment(other_boids)
            cohesion_force = boid.cohesion(other_boids)
            separation_force = boid.separation(other_boids)


            #Seperation
            #---------------------separation_force = boid.separation(other_boids)
            #boid.velocity += separation_force
            #boid.position += boid.velocity
            #Alignment
            #---------------------alignment_force = boid.alignment(other_boids)
            #boid.velocity += alignment_force
            #boid.position += boid.velocity
            #Cohesion
            #---------------------cohesion_force = boid.cohesion(other_boids)
            #boid.position += cohesion_force

            boid.velocity += alignment_force * 0.1
            boid.velocity += cohesion_force * 0.1
            boid.velocity += separation_force * 0.1

            boid.position += boid.velocity

            #Go around the plot if boid goes out of bounds by changing the position using mod 150, which is the max x and y of plot
            boid.position[0] = boid.position[0] % 150
            boid.position[1] = boid.position[1] % 150

        # Plot the Boids
        positions = np.array([boid.position for boid in boids])
        plt.scatter(positions[:, 0], positions[:, 1])

        plt.xlim(0, 150)  # Set x-axis from 0-150
        plt.ylim(0, 150)  # Set y-axis from 0-150
        plt.pause(0.5)    # Pause time between each plot

    plt.show() #Plot show


#This method combines behaviours of cohesion and separation
#used in the variables , cohesion_force, and separation_force,
#then they are added to the velocity and normalized by multiplying by 0.1
#then the position is incremented by the final velocity.
def SeparationandCohesion(boids, num_steps):
    for step in range(num_steps):
        plt.clf()  # Clear the current plot

        for boid in boids:
            other_boids = [other for other in boids if other != boid]
            #alignment_force = boid.alignment(other_boids)
            cohesion_force = boid.cohesion(other_boids)
            separation_force = boid.separation(other_boids)


            #Seperation
            #---------------------separation_force = boid.separation(other_boids)
            #boid.velocity += separation_force
            #boid.position += boid.velocity
            #Alignment
            #---------------------alignment_force = boid.alignment(other_boids)
            #boid.velocity += alignment_force
            #boid.position += boid.velocity
            #Cohesion
            #---------------------cohesion_force = boid.cohesion(other_boids)
            #boid.position += cohesion_force

            #boid.velocity += alignment_force * 0.1
            boid.velocity += cohesion_force * 0.1
            boid.velocity += separation_force * 0.1

            boid.position += boid.velocity

            #Go around the plot if boid goes out of bounds by changing the position using mod 150, which is the max x and y of plot
            boid.position[0] = boid.position[0] % 150
            boid.position[1] = boid.position[1] % 150

        # Plot the Boids
        positions = np.array([boid.position for boid in boids])
        plt.scatter(positions[:, 0], positions[:, 1])

        plt.xlim(0, 150)  # Set x-axis from 0-150
        plt.ylim(0, 150)  # Set y-axis from 0-150
        plt.pause(0.5)    # Pause time between each plot

    plt.show() #Plot show


#This method combines behaviours of alignment and separation
#used in the variables , alignment_force, and separation_force,
#then they are added to the velocity and normalized by multiplying by 0.1
#then the position is incremented by the final velocity.
def SeparationandAlignment(boids, num_steps):
    for step in range(num_steps):
        plt.clf()  # Clear the current plot

        for boid in boids:
            other_boids = [other for other in boids if other != boid]
            alignment_force = boid.alignment(other_boids)
            #cohesion_force = boid.cohesion(other_boids)
            separation_force = boid.separation(other_boids)


            #Seperation
            #---------------------separation_force = boid.separation(other_boids)
            #boid.velocity += separation_force
            #boid.position += boid.velocity
            #Alignment
            #---------------------alignment_force = boid.alignment(other_boids)
            #boid.velocity += alignment_force
            #boid.position += boid.velocity
            #Cohesion
            #---------------------cohesion_force = boid.cohesion(other_boids)
            #boid.position += cohesion_force

            boid.velocity += alignment_force * 0.1
            #boid.velocity += cohesion_force * 0.1
            boid.velocity += separation_force * 0.1

            boid.position += boid.velocity

            #Go around the plot if boid goes out of bounds by changing the position using mod 150, which is the max x and y of plot
            boid.position[0] = boid.position[0] % 150
            boid.position[1] = boid.position[1] % 150

        # Plot the Boids
        positions = np.array([boid.position for boid in boids])
        plt.scatter(positions[:, 0], positions[:, 1])

        plt.xlim(0, 150)  # Set x-axis from 0-150
        plt.ylim(0, 150)  # Set y-axis from 0-150
        plt.pause(0.5)    # Pause time between each plot

    plt.show() # Plot show


#This method combines behaviours of alignment and cohesion
#used in the variables , alignment_force, and cohesion_force,
#then they are added to the velocity and normalized by multiplying by 0.1
#then the position is incremented by the final velocity.
def CohesionandAlignment(boids, num_steps):
    for step in range(num_steps):
        plt.clf()  # Clear the current plot

        for boid in boids:
            other_boids = [other for other in boids if other != boid]
            alignment_force = boid.alignment(other_boids)
            cohesion_force = boid.cohesion(other_boids)
            #separation_force = boid.separation(other_boids)


            #Seperation
            #---------------------separation_force = boid.separation(other_boids)
            #boid.velocity += separation_force
            #boid.position += boid.velocity
            #Alignment
            #---------------------alignment_force = boid.alignment(other_boids)
            #boid.velocity += alignment_force
            #boid.position += boid.velocity
            #Cohesion
            #---------------------cohesion_force = boid.cohesion(other_boids)
            #boid.position += cohesion_force

            boid.velocity += alignment_force * 0.1
            boid.velocity += cohesion_force * 0.1
            #boid.velocity += separation_force * 0.1

            boid.position += boid.velocity

            #Go around the plot if boid goes out of bounds by changing the position using mod 150, which is the max x and y of plot
            boid.position[0] = boid.position[0] % 150
            boid.position[1] = boid.position[1] % 150

        # Plot the Boids
        positions = np.array([boid.position for boid in boids])
        plt.scatter(positions[:, 0], positions[:, 1])

        plt.xlim(0, 150)  # Set x-axis from 0-150
        plt.ylim(0, 150)  # Set y-axis from 0-150
        plt.pause(0.5)    # Pause time between each plot

    plt.show() #Plot show

#Flocking 10 boids 200 iterations

num_boids = 10
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]


#boids = [boid1, boid2]

# Specify the number of simulation steps
num_steps = 200

# Visualize cohesion behavior
visualize_flocking(boids, num_steps)

#We notice the boids start from the similar position square of between 0 and 50 x and y and they start following
#each other's general direction, while also trying to move towards each other. Which shows cohesion and alignment,
#We could also see that the flock gets separated into a couple smaller flocks and they act with cohesion and alignment as well
#Furthermore, when all flocks are near each other they rejoin each other and do the same actions again.

#Flocking 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]


#number of simulation steps
num_steps = 200

# Visualize cohesion behavior
visualize_flocking(boids, num_steps)
#The simulation of flocking with 100 boids shows similar qualities as the flocking model with 10 boids
#However, in this model, we can easily observe the flocking behaviour due to the magnitude of boid
#density/concentration.

#Separation&Cohesion 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]



# Number of simulation steps
num_steps = 200

# Visualize Separation and Cohesion behavior
SeparationandCohesion(boids, num_steps)
#In the separation and cohesion model with 100 boids over 200 iterations we start to notice
#that the boids start following the same general direction of nearby boids, however, due to the
#cohesion behaviour the distance between boids is decreasing over iterations. We notice in the start
#the boid group separates into 4 different directions, then they regroup (due to the reinitialization of position when exiting bounds)
#and go again

#Separation&Alignment 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]


# number of simulation steps
num_steps = 200

# Visualize Separation and Alignment behavior
SeparationandAlignment(boids, num_steps)
#In the separation and alignment model with 100 boids over 200 iterations we start to notice
#that the boids start following the same general direction of nearby boids, however, due to the
#separation behaviour the distance between boids is increaing over iterations. We notice in the start
#the boid group separates into 4 different directions, then they regroup (due to the reinitialization of position when exiting bounds)
#and go again

#Cohesion&Alignment 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]


# Number of simulation steps
num_steps = 200

# Visualize Cohesion and Alignment behavior
CohesionandAlignment(boids, num_steps)
#In the cohesion and alignment model with 100 boids over 200 iterations we start to notice
#that the boids start following the same general direction of nearby boids, however,
#we see that they go on 4 different groups because of the alignment directions
# and each group shows the cohesion behaviour
# then they regroup (due to the reinitialization of position when exiting bounds)
#and go again

import csv

def visualize_flocking_with_saving(boids, num_steps, output_csv_filename):
    with open(output_csv_filename, 'w', newline='') as csvfile:
        csv_writer =  csv.DictWriter(csvfile, fieldnames=["Steps", "Postion X", "Position Y", "Velocity X", "Velocity Y"])
        csv_writer.writeheader()

        for step in range(num_steps):
            plt.clf()

            for boid in boids:
                other_boids = [other for other in boids if other != boid]
                alignment_force = boid.alignment(other_boids)
                cohesion_force = boid.cohesion(other_boids)
                separation_force = boid.separation(other_boids)


                boid.velocity += alignment_force * 0.1
                boid.velocity += cohesion_force * 0.1
                boid.velocity += separation_force * 0.1


                boid.position += boid.velocity


                boid.position[0] = boid.position[0] % 200
                boid.position[1] = boid.position[1] % 200

                # Save position and velocity to CSV
                #csv_writer.writerow([step, boid.position[0], boid.position[1], boid.velocity[0], boid.velocity[1]])
                csv_writer.writerow({"Steps": step, "Postion X": boid.position[0], "Position Y": boid.position[1], "Velocity X": boid.velocity[0], "Velocity Y": boid.velocity[1]})

            # Plot the Boids
            positions = np.array([boid.position for boid in boids])
            plt.scatter(positions[:, 0], positions[:, 1])

            plt.xlim(0, 200)
            plt.ylim(0, 200)
            plt.pause(0.2)

    plt.show()






def visualize_SeparationandCohesion_with_saving(boids, num_steps, output_csv_filename):
    with open(output_csv_filename, 'w', newline='') as csvfile:
        csv_writer =  csv.DictWriter(csvfile, fieldnames=["Steps", "Postion X", "Position Y", "Velocity X", "Velocity Y"])
        csv_writer.writeheader()

        for step in range(num_steps):
            plt.clf()

            for boid in boids:
                other_boids = [other for other in boids if other != boid]
                #alignment_force = boid.alignment(other_boids)
                cohesion_force = boid.cohesion(other_boids)
                separation_force = boid.separation(other_boids)


                #boid.velocity += alignment_force * 0.1
                boid.velocity += cohesion_force * 0.1
                boid.velocity += separation_force * 0.1


                boid.position += boid.velocity


                boid.position[0] = boid.position[0] % 200
                boid.position[1] = boid.position[1] % 200

                #csv_writer.writerow([step, boid.position[0], boid.position[1], boid.velocity[0], boid.velocity[1]])
                csv_writer.writerow({"Steps": step, "Postion X": boid.position[0], "Position Y": boid.position[1], "Velocity X": boid.velocity[0], "Velocity Y": boid.velocity[1]})


            positions = np.array([boid.position for boid in boids])
            plt.scatter(positions[:, 0], positions[:, 1])

            plt.xlim(0, 200)
            plt.ylim(0, 200)
            plt.pause(0.2)

    plt.show()






def visualize_SeparationandAlignment_with_saving(boids, num_steps, output_csv_filename):
    with open(output_csv_filename, 'w', newline='') as csvfile:
        csv_writer =  csv.DictWriter(csvfile, fieldnames=["Steps", "Postion X", "Position Y", "Velocity X", "Velocity Y"])
        csv_writer.writeheader()

        for step in range(num_steps):
            plt.clf()

            for boid in boids:
                other_boids = [other for other in boids if other != boid]
                alignment_force = boid.alignment(other_boids)
                #cohesion_force = boid.cohesion(other_boids)
                separation_force = boid.separation(other_boids)


                boid.velocity += alignment_force * 0.1
                #boid.velocity += cohesion_force * 0.1
                boid.velocity += separation_force * 0.1


                boid.position += boid.velocity


                boid.position[0] = boid.position[0] % 200
                boid.position[1] = boid.position[1] % 200

                # Save position and velocity to CSV
                #csv_writer.writerow([step, boid.position[0], boid.position[1], boid.velocity[0], boid.velocity[1]])
                csv_writer.writerow({"Steps": step, "Postion X": boid.position[0], "Position Y": boid.position[1], "Velocity X": boid.velocity[0], "Velocity Y": boid.velocity[1]})


            positions = np.array([boid.position for boid in boids])
            plt.scatter(positions[:, 0], positions[:, 1])

            plt.xlim(0, 200)
            plt.ylim(0, 200)
            plt.pause(0.2)

    plt.show()




def visualize_CohesionandAlignment_with_saving(boids, num_steps, output_csv_filename):
    with open(output_csv_filename, 'w', newline='') as csvfile:
        csv_writer =  csv.DictWriter(csvfile, fieldnames=["Steps", "Postion X", "Position Y", "Velocity X", "Velocity Y"])
        csv_writer.writeheader()

        for step in range(num_steps):
            plt.clf()

            for boid in boids:
                other_boids = [other for other in boids if other != boid]
                alignment_force = boid.alignment(other_boids)
                cohesion_force = boid.cohesion(other_boids)
                #separation_force = boid.separation(other_boids)


                boid.velocity += alignment_force * 0.1  # Adjust the scaling factor as needed
                boid.velocity += cohesion_force * 0.1  # Adjust the scaling factor as needed
                #boid.velocity += separation_force * 0.1  # Adjust the scaling factor as needed


                boid.position += boid.velocity


                boid.position[0] = boid.position[0] % 200
                boid.position[1] = boid.position[1] % 200

                # Save position and velocity to CSV
                #csv_writer.writerow([step, boid.position[0], boid.position[1], boid.velocity[0], boid.velocity[1]])
                csv_writer.writerow({"Steps": step, "Postion X": boid.position[0], "Position Y": boid.position[1], "Velocity X": boid.velocity[0], "Velocity Y": boid.velocity[1]})


            positions = np.array([boid.position for boid in boids])
            plt.scatter(positions[:, 0], positions[:, 1])

            plt.xlim(0, 200)
            plt.ylim(0, 200)
            plt.pause(0.2)

    plt.show()

#Flocking 10 boids 200 iterations

num_boids = 10
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]


# Number of simulation steps
num_steps = 200

# Visualize cohesion behavior
visualize_flocking_with_saving(boids, num_steps, 'output_flocking(10 boids).csv')

#We notice the boids start from the similar position square of between 0 and 50 x and y and they start following
#each other's general direction, while also trying to move towards each other. Which shows cohesion and alignment,
#We could also see that the flock gets separated into a couple smaller flocks and they act with cohesion and alignment as well
#Furthermore, when all flocks are near each other they rejoin each other and do the same actions again.

#Flocking 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]


# Number of simulation steps
num_steps = 200

# Visualize cohesion behavior
visualize_flocking_with_saving(boids, num_steps, 'output_flocking(100 boids).csv')

#We notice the boids start from the similar position square of between 0 and 50 x and y and they start following
#each other's general direction, while also trying to move towards each other. Which shows cohesion and alignment,
#We could also see that the flock gets separated into a couple smaller flocks and they act with cohesion and alignment as well
#Furthermore, when all flocks are near each other they rejoin each other and do the same actions again.

#Separation&Cohesion 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]


# Number of simulation steps
num_steps = 200

# Visualize Separation and Cohesion behavior
visualize_SeparationandCohesion_with_saving(boids, num_steps, 'output_Separation&Cohesion(100 boids).csv')
#In the separation and cohesion model with 100 boids over 200 iterations we start to notice
#that the boids start following the same general direction of nearby boids, however, due to the
#cohesion behaviour the distance between boids is decreasing over iterations. We notice in the start
#the boid group separates into 4 different directions, then they regroup (due to the reinitialization of position when exiting bounds)
#and go again

#Separation&Alignment 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]



# Number of simulation steps
num_steps = 200

# Visualize Separation and Alignment behavior
visualize_SeparationandAlignment_with_saving(boids, num_steps, 'output_Separation&Alignment(100 boids).csv')
#In the separation and alignment model with 100 boids over 200 iterations we start to notice
#that the boids start following the same general direction of nearby boids, however, due to the
#separation behaviour the distance between boids is increaing over iterations. We notice in the start
#the boid group separates into 4 different directions, then they regroup (due to the reinitialization of position when exiting bounds)
#and go again

#Cohesion&Alignment 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]



# Number of simulation steps
num_steps = 200

# Visualize Cohesion and Alignment behavior
visualize_CohesionandAlignment_with_saving(boids, num_steps, 'output_Cohesion&Alignment(100 boids).csv')
#In the cohesion and alignment model with 100 boids over 200 iterations we start to notice
#that the boids start following the same general direction of nearby boids, however,
#we see that they go on 4 different groups because of the alignment directions
# and each group shows the cohesion behaviour
# then they regroup (due to the reinitialization of position when exiting bounds)
#and go again

def visualize_flocking_brokenforcohesion_with_saving(boids, num_steps, output_csv_filename):
    with open(output_csv_filename, 'w', newline='') as csvfile:
        csv_writer =  csv.DictWriter(csvfile, fieldnames=["Steps", "Postion X", "Position Y", "Velocity X", "Velocity Y"])
        csv_writer.writeheader()

        for step in range(num_steps):
            plt.clf()

            for boid in boids:
                other_boids = [other for other in boids if other != boid]
                alignment_force = boid.alignment(other_boids)
                cohesion_force = boid.cohesion(other_boids)
                separation_force = boid.separation(other_boids)


                boid.velocity += alignment_force * 0.1
                boid.velocity += cohesion_force
                boid.velocity += separation_force * 0.1


                boid.position += boid.velocity


                boid.position[0] = boid.position[0] % 200
                boid.position[1] = boid.position[1] % 200

                # Save position and velocity to CSV
                #csv_writer.writerow([step, boid.position[0], boid.position[1], boid.velocity[0], boid.velocity[1]])
                csv_writer.writerow({"Steps": step, "Postion X": boid.position[0], "Position Y": boid.position[1], "Velocity X": boid.velocity[0], "Velocity Y": boid.velocity[1]})


            positions = np.array([boid.position for boid in boids])
            plt.scatter(positions[:, 0], positions[:, 1])

            plt.xlim(0, 200)
            plt.ylim(0, 200)
            plt.pause(0.2)

    plt.show()

#Flocking broken (1)100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]



# Number of simulation steps
num_steps = 200

# Visualize cohesion behavior
visualize_flocking_brokenforcohesion_with_saving(boids, num_steps, 'output_flocking_broken(cohesion bias)(100 boids).csv')

#In this trial we modified the cohesion scaling factor to be the strongest one
#in the simulation of the flocking, this was done in order to hopefully see a
#swarming effect which is seen in flocks of birds when they are attacked by a bird of prey, they group
#up against the attacking bird, essentially swarming it.
#We notice that the boids start flocking but without really being influenced by
#the separation, they tend to follow the alignment and the separation, however
#not to the extent previously seen. While being unorthodox this does show a
#visualization of a swarming behaviour in a flock, whereas the flock seems to be
# always grouped

def visualize_flocking_brokenforseparation_with_saving(boids, num_steps, output_csv_filename):
    with open(output_csv_filename, 'w', newline='') as csvfile:
        csv_writer =  csv.DictWriter(csvfile, fieldnames=["Steps", "Postion X", "Position Y", "Velocity X", "Velocity Y"])
        csv_writer.writeheader()

        for step in range(num_steps):
            plt.clf()

            for boid in boids:
                other_boids = [other for other in boids if other != boid]
                alignment_force = boid.alignment(other_boids)
                cohesion_force = boid.cohesion(other_boids)
                separation_force = boid.separation(other_boids)


                boid.velocity += alignment_force * 0.1  # Adjust the scaling factor as neededS
                boid.velocity += cohesion_force * 0.1 # Adjust the scaling factor as needed
                boid.velocity += separation_force   # Adjust the scaling factor as needed


                boid.position += boid.velocity


                boid.position[0] = boid.position[0] % 200
                boid.position[1] = boid.position[1] % 200

                # Save position and velocity to CSV
                #csv_writer.writerow([step, boid.position[0], boid.position[1], boid.velocity[0], boid.velocity[1]])
                csv_writer.writerow({"Steps": step, "Postion X": boid.position[0], "Position Y": boid.position[1], "Velocity X": boid.velocity[0], "Velocity Y": boid.velocity[1]})


            positions = np.array([boid.position for boid in boids])
            plt.scatter(positions[:, 0], positions[:, 1])

            plt.xlim(0, 200)
            plt.ylim(0, 200)
            plt.pause(0.2)

    plt.show()

#Flocking broken (2) 100 boids 200 iterations

num_boids = 100
boids = [Boid([(random.randint(0,50)), (random.randint(0,50))], [(random.randint(0,1)), (random.randint(0,1))], 20, 25) for _ in range(num_boids)]



# Number of simulation steps
num_steps = 200

# Visualize cohesion behavior
visualize_flocking_brokenforseparation_with_saving(boids, num_steps, 'output_flocking_broken(separation bias)(100 boids).csv')

#In this trial we modified the separation scaling factor to be the strongest one
#in the simulation of the flocking, this was done in continuance to the previous
#attempt at analyzing different formations of flocking when a threat is present.
#In the previous attempt, it was deemed favorable to attack the threat and swarm it,
#however, in this attempt it deems necessary to avoid the threat and get away from it
#so this model supposedly will favor separation instead of cohesion and alignment.
#We see that after the simulation that the flock broke off into multiple flocks and
#kept doing so over and over again which shows the separation dominance in this
#model, however, next time the separation scaling factor needs to be larger
#due to the fact that the flock still showed noticable events of cohesion
#and alignment.

